name: "Blue-Green Deployment"

on:
  push:
    branches:
      - dev

permissions:
  id-token: write
  contents: read

env:
  CLUSTER_NAME: dev-demo
  SERVICE_NAME: app
  TASK_DEFINITION_FILE: terraform/ecs/task_definition.tpl.json
  BLUE_LISTENER_PORT: 80
  TEST_LISTENER_PORT: 5001
  TIMEOUT_MINUTES: 5

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - uses: actions/checkout@v3

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::058264525554:role/github-actions-OpsXandao-pipeline
          aws-region: us-east-1

      - name: Get ALB and Target Group Info
        id: alb-info
        run: |
          ALB_ARN=$(aws elbv2 describe-load-balancers --names demo-alb --query 'LoadBalancers[0].LoadBalancerArn' --output text)
          echo "ALB_ARN=${ALB_ARN}" >> $GITHUB_ENV
          
          PROD_LISTENER_ARN=$(aws elbv2 describe-listeners --load-balancer-arn $ALB_ARN --query 'Listeners[?Port==`80`].ListenerArn' --output text)
          TEST_LISTENER_ARN=$(aws elbv2 describe-listeners --load-balancer-arn $ALB_ARN --query 'Listeners[?Port==`5001`].ListenerArn' --output text)
          
          echo "PROD_LISTENER_ARN=${PROD_LISTENER_ARN}" >> $GITHUB_ENV
          echo "TEST_LISTENER_ARN=${TEST_LISTENER_ARN}" >> $GITHUB_ENV
          
          # Get current production target group
          CURRENT_PROD_TG_ARN=$(aws elbv2 describe-listeners --listener-arn $PROD_LISTENER_ARN --query 'Listeners[0].DefaultActions[0].TargetGroupArn' --output text)
          echo "CURRENT_PROD_TG_ARN=${CURRENT_PROD_TG_ARN}" >> $GITHUB_ENV

      - name: Get current task definition
        id: get-taskdef
        run: |
          aws ecs describe-task-definition \
            --task-definition demo-teste \
            --query 'taskDefinition' \
            --output json > current-task-def.json
          
          echo "CURRENT_IMAGE=$(jq -r '.containerDefinitions[0].image' current-task-def.json)" >> $GITHUB_ENV
          echo "TASK_DEF_FILE=current-task-def.json" >> $GITHUB_OUTPUT

      - name: Deploy new task definition
        id: deploy
        run: |
          # Register new task definition
          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://${{ env.TASK_DEFINITION_FILE }} \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          echo "NEW_TASK_DEF_ARN=${NEW_TASK_DEF_ARN}" >> $GITHUB_ENV
          
          # Update the service with new task definition
          aws ecs update-service \
            --cluster ${{ env.CLUSTER_NAME }} \
            --service ${{ env.SERVICE_NAME }} \
            --task-definition $NEW_TASK_DEF_ARN \
            --force-new-deployment

          # Monitor deployment
          echo "Monitoring deployment..."
          START_TIME=$(date +%s)
          TIMEOUT=$((${TIMEOUT_MINUTES} * 60))
          
          while true; do
            DEPLOYMENT_STATUS=$(aws ecs describe-services \
              --cluster ${{ env.CLUSTER_NAME }} \
              --services ${{ env.SERVICE_NAME }} \
              --query 'services[0].deployments[0].status' \
              --output text)
            
            RUNNING_COUNT=$(aws ecs describe-services \
              --cluster ${{ env.CLUSTER_NAME }} \
              --services ${{ env.SERVICE_NAME }} \
              --query 'services[0].runningCount' \
              --output text)
            
            CURRENT_TIME=$(date +%s)
            ELAPSED_TIME=$((CURRENT_TIME - START_TIME))
            
            if [ "$DEPLOYMENT_STATUS" = "PRIMARY" ] && [ "$RUNNING_COUNT" -ge 1 ]; then
              echo "Deployment successful! Tasks are running."
              break
            fi
            
            if [ $ELAPSED_TIME -gt $TIMEOUT ]; then
              echo "Deployment timed out after ${TIMEOUT_MINUTES} minutes"
              exit 1
            fi
            
            echo "Deployment status: $DEPLOYMENT_STATUS (Running: $RUNNING_COUNT). Waiting..."
            sleep 30
          done

      - name: Health check deployment
        id: health-check
        run: |
          echo "Performing health checks..."
          ALB_DNS=$(aws elbv2 describe-load-balancers \
            --names demo-alb \
            --query 'LoadBalancers[0].DNSName' \
            --output text)
          
          MAX_RETRIES=5
          RETRY_COUNT=0
          
          # Check both production and test endpoints
          for PORT in 80 5001; do
            echo "Testing port $PORT..."
            RETRY_COUNT=0
            
            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "http://$ALB_DNS:$PORT/")
              
              if [ "$HTTP_STATUS" -eq 200 ]; then
                echo "Health check passed on port $PORT!"
                break
              fi
              
              RETRY_COUNT=$((RETRY_COUNT + 1))
              echo "Health check attempt $RETRY_COUNT failed on port $PORT. Status: $HTTP_STATUS"
              
              if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
                echo "Health check failed after $MAX_RETRIES attempts on port $PORT"
                exit 1
              fi
              
              sleep 30
            done
          done
          
          echo "STATUS=success" >> $GITHUB_OUTPUT

      - name: Switch production traffic
        if: success()
        run: |
          # Get target group ARNs
          BLUE_TG_ARN=$(aws elbv2 describe-target-groups \
            --names main \
            --query 'TargetGroups[0].TargetGroupArn' \
            --output text)
          
          GREEN_TG_ARN=$(aws elbv2 describe-target-groups \
            --names green \
            --query 'TargetGroups[0].TargetGroupArn' \
            --output text)
          
          # Determine current and new target groups
          if [ "$CURRENT_PROD_TG_ARN" = "$BLUE_TG_ARN" ]; then
            NEW_PROD_TG_ARN=$GREEN_TG_ARN
          else
            NEW_PROD_TG_ARN=$BLUE_TG_ARN
          fi
          
          # Switch production listener to new target group
          aws elbv2 modify-listener \
            --listener-arn $PROD_LISTENER_ARN \
            --default-actions Type=forward,TargetGroupArn=$NEW_PROD_TG_ARN
          
          echo "Production traffic switched to new target group"

      - name: Rollback on failure
        if: failure()
        run: |
          echo "Deployment failed, rolling back..."
          
          PREVIOUS_TASK_DEF_ARN=$(jq -r '.taskDefinitionArn' ${{ steps.get-taskdef.outputs.TASK_DEF_FILE }})
          
          # Rollback to previous task definition
          aws ecs update-service \
            --cluster ${{ env.CLUSTER_NAME }} \
            --service ${{ env.SERVICE_NAME }} \
            --task-definition $PREVIOUS_TASK_DEF_ARN \
            --force-new-deployment
          
          # Restore original production target group
          aws elbv2 modify-listener \
            --listener-arn $PROD_LISTENER_ARN \
            --default-actions Type=forward,TargetGroupArn=$CURRENT_PROD_TG_ARN
          
          # Monitor rollback
          START_TIME=$(date +%s)
          while true; do
            DEPLOYMENT_STATUS=$(aws ecs describe-services \
              --cluster ${{ env.CLUSTER_NAME }} \
              --services ${{ env.SERVICE_NAME }} \
              --query 'services[0].deployments[0].status' \
              --output text)
            
            RUNNING_COUNT=$(aws ecs describe-services \
              --cluster ${{ env.CLUSTER_NAME }} \
              --services ${{ env.SERVICE_NAME }} \
              --query 'services[0].runningCount' \
              --output text)
            
            if [ "$DEPLOYMENT_STATUS" = "PRIMARY" ] && [ "$RUNNING_COUNT" -ge 1 ]; then
              echo "Rollback completed successfully"
              exit 0
            fi
            
            CURRENT_TIME=$(date +%s)
            if [ $((CURRENT_TIME - START_TIME)) -gt 300 ]; then
              echo "Rollback timed out after 5 minutes"
              exit 1
            fi
            
            echo "Rollback status: $DEPLOYMENT_STATUS. Waiting..."
            sleep 30
          done