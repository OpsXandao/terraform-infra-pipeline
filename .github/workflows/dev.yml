name: "Blue-Green Deployment"

on:
  push:
    branches:
      - dev

permissions:
  id-token: write
  contents: read

env:
  CLUSTER_NAME: dev-demo
  SERVICE_NAME: app
  TASK_DEFINITION_FILE: terraform/ecs/task_definition.tpl.json
  BLUE_LISTENER_PORT: 80
  TEST_LISTENER_PORT: 5001
  TIMEOUT_MINUTES: 5

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - uses: actions/checkout@v3

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::058264525554:role/github-actions-OpsXandao-pipeline
          aws-region: us-east-1

      - name: Get current task definition
        id: get-taskdef
        run: |
          aws ecs describe-task-definition \
            --task-definition demo-teste \
            --query 'taskDefinition' \
            --output json > current-task-def.json
          
          echo "CURRENT_IMAGE=$(jq -r '.containerDefinitions[0].image' current-task-def.json)" >> $GITHUB_ENV
          echo "TASK_DEF_FILE=current-task-def.json" >> $GITHUB_OUTPUT

      - name: Deploy new task definition
        id: deploy
        run: |
          # Register new task definition
          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://${{ env.TASK_DEFINITION_FILE }} \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          echo "NEW_TASK_DEF_ARN=${NEW_TASK_DEF_ARN}" >> $GITHUB_ENV
          
          # Update the service
          aws ecs update-service \
            --cluster ${{ env.CLUSTER_NAME }} \
            --service ${{ env.SERVICE_NAME }} \
            --task-definition $NEW_TASK_DEF_ARN \
            --force-new-deployment

          # Monitor deployment
          echo "Monitoring deployment..."
          START_TIME=$(date +%s)
          TIMEOUT=$((${TIMEOUT_MINUTES} * 60))
          
          while true; do
            DEPLOYMENT_STATUS=$(aws ecs describe-services \
              --cluster ${{ env.CLUSTER_NAME }} \
              --services ${{ env.SERVICE_NAME }} \
              --query 'services[0].deployments[0].status' \
              --output text)
            
            CURRENT_TIME=$(date +%s)
            ELAPSED_TIME=$((CURRENT_TIME - START_TIME))
            
            if [ "$DEPLOYMENT_STATUS" = "PRIMARY" ]; then
              # Check if tasks are running
              RUNNING_COUNT=$(aws ecs describe-services \
                --cluster ${{ env.CLUSTER_NAME }} \
                --services ${{ env.SERVICE_NAME }} \
                --query 'services[0].runningCount' \
                --output text)
              
              if [ "$RUNNING_COUNT" -ge 1 ]; then
                echo "Deployment successful! Tasks are running."
                exit 0
              fi
            fi
            
            if [ $ELAPSED_TIME -gt $TIMEOUT ]; then
              echo "Deployment timed out after ${TIMEOUT_MINUTES} minutes"
              exit 1
            fi
            
            echo "Deployment status: $DEPLOYMENT_STATUS. Waiting..."
            sleep 30
          done

      - name: Health check deployment
        id: health-check
        if: success()
        run: |
          echo "Performing health check..."
          ALB_DNS=$(aws elbv2 describe-load-balancers \
            --names demo-alb \
            --query 'LoadBalancers[0].DNSName' \
            --output text)
          
          # Multiple retries for health check
          MAX_RETRIES=5
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "http://$ALB_DNS:80/")
            
            if [ "$HTTP_STATUS" -eq 200 ]; then
              echo "Health check passed!"
              echo "STATUS=success" >> $GITHUB_OUTPUT
              exit 0
            fi
            
            RETRY_COUNT=$((RETRY_COUNT + 1))
            echo "Health check attempt $RETRY_COUNT failed. Status: $HTTP_STATUS"
            sleep 30
          done
          
          echo "Health check failed after $MAX_RETRIES attempts"
          echo "STATUS=failure" >> $GITHUB_OUTPUT
          exit 1

      - name: Rollback on failure
        if: failure()
        run: |
          echo "Deployment failed, rolling back..."
          
          # Get the previous task definition
          PREVIOUS_TASK_DEF_ARN=$(jq -r '.taskDefinitionArn' ${{ steps.get-taskdef.outputs.TASK_DEF_FILE }})
          
          # Rollback to previous task definition
          aws ecs update-service \
            --cluster ${{ env.CLUSTER_NAME }} \
            --service ${{ env.SERVICE_NAME }} \
            --task-definition $PREVIOUS_TASK_DEF_ARN \
            --force-new-deployment
          
          # Monitor rollback
          START_TIME=$(date +%s)
          
          while true; do
            DEPLOYMENT_STATUS=$(aws ecs describe-services \
              --cluster ${{ env.CLUSTER_NAME }} \
              --services ${{ env.SERVICE_NAME }} \
              --query 'services[0].deployments[0].status' \
              --output text)
            
            CURRENT_TIME=$(date +%s)
            ELAPSED_TIME=$((CURRENT_TIME - START_TIME))
            
            if [ "$DEPLOYMENT_STATUS" = "PRIMARY" ] && \
               [ "$(aws ecs describe-services \
                    --cluster ${{ env.CLUSTER_NAME }} \
                    --services ${{ env.SERVICE_NAME }} \
                    --query 'services[0].runningCount' \
                    --output text)" -ge 1 ]; then
              echo "Rollback completed successfully"
              exit 0
            fi
            
            if [ $ELAPSED_TIME -gt 300 ]; then
              echo "Rollback timed out after 5 minutes"
              exit 1
            fi
            
            echo "Rollback status: $DEPLOYMENT_STATUS. Waiting..."
            sleep 30
          done